var documenterSearchIndex = {"docs":
[{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"It is often the case that you can not code every information we would like to have. Principly, you are not required to write anything:","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"DocTestFilters = [r\"May we suggest: .*\", r\"└ @ Taxonomy .*\"]","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"julia> using Taxonomy\n\njulia> Record()\n┌ Warning: Please provide your rater ID. This should be your initials.\n└ @ Taxonomy ~/Dokumente/GitHub/Taxonomy.jl/src/record.jl:16\n┌ Warning: You really should supply an ID. May we suggest: e23f1ede-e271-4b4c-b692-7adc02f8d79e\n└ @ Taxonomy ~/Dokumente/GitHub/Taxonomy.jl/src/record.jl:22\n┌ Warning: You really should supply a location.\n└ @ Taxonomy ~/Dokumente/GitHub/Taxonomy.jl/src/record.jl:27\n┌ Warning: Some of the metadata seem to be incomplete. Check again.\n└ @ Taxonomy ~/Dokumente/GitHub/Taxonomy.jl/src/record.jl:33\nRecord\n   rater: Missing\n   id: Missing\n   location: NoLocation\n   meta: IncompleteMeta\n   judgements: Dict{Symbol, Vector{Union{Study, AbstractJudgement}}}","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"As you probably notice we warn you to do that. This is to encourage you to think twice, however, after having thought twice about it, you may silence every warning with explicitly suppliyng \"empty\" instances (except ID, really nothing should hinder you to supply a random id).","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"Record(\n   rater = \"AP\",\n   id = \"6ca721fe-619e-42cc-ad8b-047c5e0451e5\",\n   location = NoLocation(),\n   meta = MetaData(missing, missing, missing),\n   Study(Model(NoTaxon()))\n)\n\n# output\nRecord\n   rater: String\n   id: Base.UUID\n   location: NoLocation\n   meta: IncompleteMeta\n   judgements: Dict{Symbol, Vector{Union{Study, AbstractJudgement}}}","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"We therefore differenciate between \"lazy\" missings and intentional missings. The former remind you that you missed them, the latter will not bother you.","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"Another, unfortunately more complicated distinction, is between things you have tried to find out and determined that they probably are not accessable, and things that you havened made your mind up about. We assume that missings in about metadata belong to the first category (you tried to find out, but could not) and that missings about judgements about the paper belong to the second category (you have not bothered to find out). We make this distinction because you might think that it takes to much time to find something out and want to express that you are not certain it exists. But sometimes you have checked but it really does not exist. E.g. at first glance you have not found a dataset, than use NoJudgement(). It implies that you are absolutly uncertain that this is missing:","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"julia> NoJudgement()\nJudgement{Missing}(missing, 0.0, missing)","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"Or you have checked everywhere but there does not seem to be any data, than use:","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"julia> Judgement(false, 1.0) # false = no data, 1 = certain\nJudgement{Bool}(false, 1.0, missing)","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"If you want to highlight in the Record of a paper, that there is no model in the paper, that should be coded, use NoTaxon(). If however you found a paper you were unable to code, due to limitations of the package or your own knowledge, hence you want to mark it to come back to it later, use NoTaxonYet().This could look like this:","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"Record(rater = \"AP\",\nid = \"6ca721fe-619e-42cc-ad8b-047c5e0451e5\",\nlocation = NoLocation(),\nmeta = MetaData(missing, missing, missing),\nStudy(Model(NoTaxonEver())))\n\n# output\n\nRecord\n   rater: String\n   id: Base.UUID\n   location: NoLocation\n   meta: IncompleteMeta\n   judgements: Dict{Symbol, Vector{Union{Study, AbstractJudgement}}}","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"or like this:","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"Record(rater = \"AP\",\nid = \"6ca721fe-619e-42cc-ad8b-047c5e0451e5\",\nlocation = NoLocation(),\nmeta = MetaData(missing, missing, missing),\nStudy(Model(NoTaxonYet(\"2023-06-06\"))))\n\n# output\n┌ Warning: This model is currently not possible to code? - please come back later.\n└ @ Taxonomy ~/Dokumente/GitHub/Taxonomy.jl/src/taxons/no_taxon.jl:34\nRecord\n   rater: String\n   id: Base.UUID\n   location: NoLocation\n   meta: IncompleteMeta\n   judgements: Dict{Symbol, Vector{Union{Study, AbstractJudgement}}}","category":"page"},{"location":"tutorials/missing/","page":"Something is missing","title":"Something is missing","text":"DocTestFilters = nothing","category":"page"},{"location":"tutorials/judgement/","page":"Adding custom Judgements","title":"Adding custom Judgements","text":"Judgments are an integral part of Taxonomy. They represent whatever you want to code about a Record. More specifically, a Judgement might be about the Record, a Study within a Record, or about a Model.  To define a judgment you must supply a name, on which JudgementLevel it is (Study, Record, Model), some documentation (i.e., what it is you want to code), and optionally, type constrains, a function to check the validity (e.g., N can not be smaller than zero), and if the judgement can only be made once (unique).","category":"page"},{"location":"tutorials/judgement/","page":"Adding custom Judgements","title":"Adding custom Judgements","text":"using Taxonomy\nusing Taxonomy.Judgements\n## We can also do specific input checks, e.g. if we want to check if the input has a predefined value:\n@newjudgement(\n    Access,\n    RecordJudgement,\n    \"\"\"\n    A judgement type that codes how accessable a paper is.\n    \"\"\",\n    AbstractString,\n    x -> x in [\"open\", \"closed\", \"none\"] ? nothing : throw(ArgumentError(\"Not an agreed upon value.\"))\n)\nAccess(\"open\")\nAccess(\"not open\")","category":"page"},{"location":"tutorials/judgement/","page":"Adding custom Judgements","title":"Adding custom Judgements","text":"By default, Judments are assumed to be unique, i.e., there can only be one. If specified more than once, such a Judgement will throw an error. Judgements with unique = false are gathered into a vector.","category":"page"},{"location":"tutorials/software-versions/#Tutorial:-Installing,-Updating,-and-Versioning-Taxonomy.jl","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Tutorial: Installing, Updating, and Versioning Taxonomy.jl","text":"","category":"section"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"This tutorial provides a detailed guide on installing the Taxonomy.jl package,  obtaining a specific version of the package by using a commit hash, and implementing bug fixes through branching. Additionally, we will also discuss the role of Manifest.toml and Project.toml files in package versioning.","category":"page"},{"location":"tutorials/software-versions/#Installing-the-Newest-Version-of-the-Package","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing the Newest Version of the Package","text":"","category":"section"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"To install the newest version of Taxonomy.jl, you can use Julia's package manager. Open the Julia REPL and run the following commands:","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"import Pkg\nusing Pkg\nPkg.add(url = \"https://github.com/formal-methods-mpi/Taxonomy.jl\")","category":"page"},{"location":"tutorials/software-versions/#Using-Pkg.instantiate-to-Set-Up-the-Environment","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Using Pkg.instantiate to Set Up the Environment","text":"","category":"section"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"When working with Julia packages, it is often important to ensure that your environment is consistent with the project's specifications. This is particularly crucial when you are working on a project that has a specific set of dependencies. The Pkg.instantiate() command helps in setting up such an environment.","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Use the following command in Julia to instantiate the environment:","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"using Pkg\nPkg.instantiate()","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"In short:Pkg.instantiate() installs the dependencies that are specified in the Project.toml and Manifest.toml files of a project.","category":"page"},{"location":"tutorials/software-versions/#Installing-the-Version-of-One-Commit-in-the-Package's-History","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing the Version of One Commit in the Package's History","text":"","category":"section"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"If you want to install a specific version of Taxonomy.jl corresponding to a particular commit, you can do so by specifying the commit hash.  To find the commit hash, go to the Taxonomy.jl GitHub repository, click on the commit, and copy the hash.","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Use the following command to add the package based on the commit hash:","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Pkg.add(url=\"https://github.com/formal-methods-mpi/Taxonomy.jl\", rev=\"commit_hash_here\")","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Replace commit_hash_here with the actual hash of the commit you are interested in.","category":"page"},{"location":"tutorials/software-versions/#Implementing-Bug-Fixes-by-Branching-from-the-Main-Branch","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Implementing Bug Fixes by Branching from the Main Branch","text":"","category":"section"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"If you need to implement bug fixes, you can create a new branch from the main branch of the repository,  make your changes, and install the package from that branch.","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Fork the Taxonomy.jl repository to your account.\nClone the repository to your local machine.\nCreate a new branch: git checkout -b bugfix_branch.\nMake your changes and commit them.\nPush the branch to your GitHub repository: git push origin bugfix_branch.\nTo install this branch as your version of the package, use:","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Pkg.add(url=\"https://github.com/your_username/Taxonomy.jl\", rev=\"bugfix_branch\")","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Replace your_username with your GitHub username.","category":"page"},{"location":"tutorials/software-versions/#Relating-to-Manifest.toml-and-Project.toml","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Relating to Manifest.toml and Project.toml","text":"","category":"section"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Project.toml: This file contains metadata about the package, including its name, version, dependencies, and compatibility constraints.  When you specify a version or branch, Julia uses the information in Project.toml to resolve dependencies.","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"Manifest.toml: This file contains the exact versions of the dependencies that your package used.  It enables reproducible environments by pinning each dependency to a specific version.","category":"page"},{"location":"tutorials/software-versions/","page":"Installing, Updating, and Versioning Taxonomy.jl","title":"Installing, Updating, and Versioning Taxonomy.jl","text":"When you install a package, Julia uses the Project.toml to determine which versions of the dependencies are compatible.  It then generates or updates a Manifest.toml with the specific versions that were installed.  This is crucial for ensuring that your environment is reproducible and that the package will work with the set of dependencies specified in the Manifest.toml. Pkg.instantiate() will take the Manifest.toml and ensures that exactly these versions are installed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Taxonomy","category":"page"},{"location":"#Taxonomy","page":"Home","title":"Taxonomy","text":"","category":"section"},{"location":"#What?","page":"Home","title":"What?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Taxonomy.jl aims to serve as a comprehensive database of structural equation models (SEMs) that can be used to infer distributions of both structures (e.g., types of models, numbers of observed and latent variables) and parameters (e.g., what is the average factor loading). This will greatly facilitate simulation studies that accurately reflect real-world conditions and therefore takes the idea that \"Simulation studies are to a statistician what experiments are to a scientist\" Pawel & Kook et al. seriously. Having a common basis for setting parameters in simulations will also reduce the extremely wide latitude that statisticians have to create an overly positive image of the strengths of novel methods. So-called researchers-degrees of freedom are already a concern in empirical studies but simulation studies exaggerate the issue by allowing an almost infinite freedom over the data-generating process. Additionally, Taxonomy.jl will provide a user-friendly interface for researchers to easily sample these parameters for use in their own simulation studies.","category":"page"},{"location":"#End-product","page":"Home","title":"End product","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package that enables filtering a taxonomy database and construct samplers for structure and parameters. These samplers can quickly be turned into models for StructuralEquationModels.jl.","category":"page"},{"location":"#So-what?","page":"Home","title":"So what?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulations are only helpful in so far as they reflect some (simplified) aspects of reality. A simulation, that is only based on the guess of the researchers conducting it, is prone to fail to represent realistic conditions and may even favour the procedures that are investigated unduly. Being able to base simulations on a sample of the literature strengthens the inference and practical impact of simulation studies.","category":"page"},{"location":"#Impact-on-scientific-community","page":"Home","title":"Impact on scientific community","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia package will provide an according database and interface, and therefore lower the threshold for the conduction of (better) simulation studies.  By this, it may enable more general claims and facilitate preregistration of simulations. Furthermore, Bayesian methodology has highlighted the importance of incorporating prior knowledge in the form of prior distributions. Taxonomy.jl seeks to make this process more transparent and accessible for researchers and consumers of science, which can greatly facilitate cumulative science. Besides enabling better simulations, knowing how common different types of SEMs are may greatly help guiding the development of new methodologies.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Data-Base","page":"Home","title":"Data Base","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RecordDatabase","category":"page"},{"location":"#Taxonomy.RecordDatabase","page":"Home","title":"Taxonomy.RecordDatabase","text":"RecordDatabase\n\nRecords need to be stored somewhere.\n\njulia> RecordDatabase()\nRecordDatabase{Base.UUID, Record}()\n\njulia> first = Record(rater = \"AP\", id = \"552ef675-5c7b-4ce1-880b-c45b833fdfcb\", location = NoLocation(), meta = MetaData(missing, missing, missing));\n\njulia> second = Record(rater = \"AP\", id = \"58c55701-0362-40c7-849c-5d12e5026238\", location = NoLocation(), meta = MetaData(missing, missing, missing));\n\njulia> rd = RecordDatabase(first, second)\nRecordDatabase{Base.UUID, Record} with 2 entries:\n  UUID(\"58c55701-0362-40c7… => Record…\n  UUID(\"552ef675-5c7b-4ce1… => Record…\n\njulia> rd += Record(id=\"921c777a-0cc6-44da-a444-e610bfacbb07\", rater=\"AP\", location=NoLocation(), meta = MetaData(missing, missing, missing))\nRecordDatabase{Base.UUID, Record} with 3 entries:\n  UUID(\"921c777a-0cc6-44da… => Record…\n  UUID(\"58c55701-0362-40c7… => Record…\n  UUID(\"552ef675-5c7b-4ce1… => Record…\n\n\n\n\n\n","category":"type"},{"location":"#Taxons","page":"Home","title":"Taxons","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Taxonomy, AbstractTrees\nAbstractTrees.children(d::DataType) = subtypes(d)\nprint_tree(Taxonomy.Taxon)\nTaxon\n├─ AbstractCFA\n│  └─ Measurement\n├─ AbstractCLPM\n├─ AbstractLGCM\n│  └─ SimpleLGCM\n├─ AbstractPathmodel\n│  └─ Structural\n└─ NoAbstractTaxon\n   └─ NoTaxon","category":"page"},{"location":"","page":"Home","title":"Home","text":"Taxon","category":"page"},{"location":"#Taxonomy.Taxon","page":"Home","title":"Taxonomy.Taxon","text":"Taxon is the supertype of all taxons.\n\n\n\n\n\n","category":"type"},{"location":"#CFA","page":"Home","title":"CFA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Measurement","category":"page"},{"location":"#Taxonomy.Measurement","page":"Home","title":"Taxonomy.Measurement","text":"Measurement AbstractCFA.  Building Block for Taxonomy. Multiple Measurements can be combined to a Taxon. \n\nArguments\n\nn_variables: Number of variables (possibly observed/manifest). If items are parceled, this is the number of parcels.\nloadings: Vector of loadings, one for each item. \nfactor_variance: Variance of the factor.\nerror_variances: Vector of variances of the respective errors\nerror_covariances_within: Vector of covariances within factor. If unknown, set to missing, if there are no covariances, set to Float64[].\nerror_covariances_between: Vector of covariances the factor shares with a different factor. If unknown, set to missing, if there are no covariances, set to Float64[].\ncrossloadings_incoming: Vector of crossloadings coming from other factors. They should be lower than the loading coming to the item from this factor.  If unknown, set to missing, if there are none, set to Float64[]. \ncrossloadings_outgoing: Vector of crossloadings going to other items which have higher loadings from other factors. If unknown, set to missing, if there are none, set to Float64[].\nquest_scale: Scale of the questionnaire. Anything more than ten is Inf. E.g: 5 point likert scale -> 5. \n\nMeasurement(n_variables = 2, loadings = [1, 0.4], factor_variance = 0.6, quest_scale = 5)\n\n# output\n\nMeasurement\n   n_variables: JudgementInt{Int64}\n   loadings: JudgementVecNumber{Vector{Float64}}\n   factor_variance: JudgementNumber{Float64}\n   error_variances: JudgementVecNumber{Missing}\n   error_covariances_within: JudgementVecNumber{Missing}\n   error_covariances_between: JudgementVecNumber{Missing}\n   crossloadings_incoming: JudgementVecNumber{Missing}\n   crossloadings_outgoing: JudgementVecNumber{Missing}\n   quest_scale: JudgementNumber{Int64}\n\n\n\n\n\n","category":"type"},{"location":"#Pathmodels","page":"Home","title":"Pathmodels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Structural\nLatentPathmodel","category":"page"},{"location":"#Taxonomy.Structural","page":"Home","title":"Taxonomy.Structural","text":"Structural AbstractPathmodel.  Consists of a graph from StenoGraphs (structural model). \n\nArguments\n\nstructural_model: Graph from StenoGraphs package. Defines the latent relations between the factors of measurement_model.  \n\nusing StenoGraphs\n\ngraph = @StenoGraph begin\n    # latent regressions\n    fac1 → fac2\nend\n\nStructural(structural_model = graph)\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.LatentPathmodel","page":"Home","title":"Taxonomy.LatentPathmodel","text":"Create a new LatentPathmodel instance.\n\nfor indexing: mymodel.structuralmodel.structuralmodel mymodel.measurement_model[:fac2]\n\nusing StenoGraphs\ngraph = @StenoGraph begin\n    # latent regressions\n    fac1 → fac2\nend\n\nmy_model = LatentPathmodel(\n    Structural(structural_model = graph),\n    Dict(\n        :fac1 => Measurement(n_variables = 2, loadings = [1, 0.4], factor_variance = 0.6),\n        :fac2 => Measurement(n_variables = 2, loadings = [1, 0.4], factor_variance = 0.6)\n    )\n)\n\n# output\n\nLatentPathmodel\n   structural_model: Structural\n   measurement_model: Dict{Symbol, Measurement}\n\n\n\n\n\n","category":"type"},{"location":"#Cross-Lagged-Panel-Model","page":"Home","title":"Cross Lagged Panel Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Linear-Growth-Curve-Model","page":"Home","title":"Linear Growth Curve Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimpleLGCM","category":"page"},{"location":"#Taxonomy.SimpleLGCM","page":"Home","title":"Taxonomy.SimpleLGCM","text":"SimpleLGCM AbstractLGCM.  Taxon for Linear Growth Curve Model.\n\n## Arguments\n\nn_timepoints: Number of measurement timepoints.\ntimecoding: Vector containing the coding of the measurement time points (loadings of the slope onto the timepoints).\nintercept: Intercept constant.\nslope: Slope constant. \nnonlinear_timecoding: Vector for the timecodings introduced by a nonlinear function. \nvariance_intercept: Variance of the intercept.\nvariance_slope: Variance of the slope. \ncovariance_intercept_slope: Covariance between intercept and slope.\nvariances_timepoints: Vector with variances of the timepoint variables. \nn_predictors: Number of predictors on intercept and slope. \npredictor_paths_intercept: Vector for the predictor-paths to the intercept.\npredictor_paths_slope: Vector for the predictor-paths to the slope.\n\nSimpleLGCM(n_timepoints = 6, timecoding = [0, 1, 2, 3, 4, 5], intercept = 10.2, \nslope = 0.96, nonlinear_timecoding = [1, 2, 4, 9, 16, 25], variance_intercept = 1, variance_slope = 1, covariance_intercept_slope = 0.1,\nn_predictors = 2, predictor_paths_intercept = [2, 4], predictor_paths_slope = [3, 5])\n\n# output\nSimpleLGCM\n   n_timepoints: JudgementInt{Int64}\n   timecoding: JudgementVecNumber{Vector{Int64}}\n   intercept: JudgementNumber{Float64}\n   slope: JudgementNumber{Float64}\n   nonlinear_timecoding: JudgementVecNumber{Vector{Int64}}\n   variance_intercept: JudgementNumber{Int64}\n   variance_slope: JudgementNumber{Int64}\n   covariance_intercept_slope: JudgementNumber{Float64}\n   variances_timepoints: JudgementNumber{Missing}\n   n_predictors: JudgementInt{Int64}\n   predictor_paths_intercept: JudgementVecNumber{Vector{Int64}}\n   predictor_paths_slope: JudgementVecNumber{Vector{Int64}}\n\n\n\n\n\n","category":"type"},{"location":"#No-Taxon","page":"Home","title":"No Taxon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NoTaxonEver\nNoTaxonYet","category":"page"},{"location":"#Taxonomy.NoTaxonEver","page":"Home","title":"Taxonomy.NoTaxonEver","text":"NoTaxonEver()\n\nA Taxon to show, that there is no SEM to code in this paper.\n\njulia> NoTaxonEver()\nNoTaxonEver\n\njulia> NoTaxon()\nNoTaxonEver\n\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.NoTaxonYet","page":"Home","title":"Taxonomy.NoTaxonYet","text":"NoTaxonYet()\n\nA Taxon to show, that there is in fact a model to be coded, but this is at the current point not possible. NoTaxonYet requires a timestamp 'accessdate' to further specify at what point there were no possibility to code the respective model. NoTaxonYet gives you the option to name the 'modeltype', you were not able to code, to spare your future self the work of going everything through.\n\njulia> NoTaxonYet()\n\n\n\n\n\n","category":"type"},{"location":"#Extractors","page":"Home","title":"Extractors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"factor_variance\nstructural_model","category":"page"},{"location":"#Taxonomy.factor_variance","page":"Home","title":"Taxonomy.factor_variance","text":"Function to extract factor variance.\n\nArguments\n\nx: Measurement or Standalone_Factor.\n\nReturn\n\nReturns a Judgement\n\nf = Measurement(n_variables = 2, loadings = [1, 0.4], factor_variance = 1.0)\nrating(factor_variance(f))\n\n# output\n1.0\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.structural_model","page":"Home","title":"Taxonomy.structural_model","text":"Function to extract the StenoGraphs structural model from [Structural].\n\nArguments\n\nx: Strucutral.\n\nReturn\n\nReturns a Judgement\n\nusing Taxonomy\nusing StenoGraphs\n\ngraph = @StenoGraph begin\n    # latent regressions\n    fac1 → fac2\nend\n\nstruct_model = Structural(structural_model = graph)\n\nstructural_model(struct_model)\n\n\n\n\n\nExtract Structural part from a Taxon. \n\n\n\n\n\n","category":"function"},{"location":"#Levels","page":"Home","title":"Levels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Record\nStudy\nModel","category":"page"},{"location":"#Taxonomy.Record","page":"Home","title":"Taxonomy.Record","text":"Record(j...; rater = missing, id = missing, location = missing, meta = missing)\n\nRecord represents every paper(like) thing that is coded. It contains who is rating it, what is being rated (uniquely identified by an id), where to find it (location) and other metadata (usually automatically infered). If id is missing, a warning will be generated and an ID will be suggested.  This ID is linked to the location (either a DOI or URL).  If no location is provided, the ID will be generated at random.  You can use this suggested ID or generate your own using generate_id(DOI(\"yourdoi\")) or generate_id(url(\"yoururl\")).\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.Study","page":"Home","title":"Taxonomy.Study","text":"Study()\n\nUse this function to group together multiple Judgements and/or Taxons on the Study level. \n\nReturn: Output value will be a dictionary containing StudyJudgements and/or Taxons. \n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.Model","page":"Home","title":"Taxonomy.Model","text":"Model()\n\nUse this function to group together multiple Judgements and/or Taxons on the Model level. \n\nReturn: Output value will be a dictionary containing ModelJudgements and/or Taxons. \n\n\n\n\n\n","category":"type"},{"location":"#ID","page":"Home","title":"ID","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"generate_id","category":"page"},{"location":"#Taxonomy.generate_id","page":"Home","title":"Taxonomy.generate_id","text":"Generate an Entry ID\n\nTo create links between entries we need a stable reference point. This ID is generated initially from url(location) and if the url is missing, it is generated randomly. After the ID is generated once, it is saved with the Record and should not be changed.\n\n\n\n\n\n","category":"function"},{"location":"#Judgement","page":"Home","title":"Judgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Judgement\nJ\nNoJudgement\nrating\ncertainty","category":"page"},{"location":"#Taxonomy.Judgements.Judgement","page":"Home","title":"Taxonomy.Judgements.Judgement","text":"Judgement(r::Union{<: Any, Missing}, c = 1.0, l = missing})\n\nLevel: Taxonomy.Judgements.AnyLevelJudgement\n\nA generic judgment without any checks on content.\n\nArguments\n\nrating: The rating, e.g. \"Structural\" or 1.0.\ncertainty: If uncertain, a number between 0.0 and 1.0 (0-100%)\ncomment: information on why the judgement was made, may contain information about the source within the paper, e.g., section, page, table number, figure number.\n\njulia> Judgement(1.0, .99, \"Figure 1\");\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.Judgements.J","page":"Home","title":"Taxonomy.Judgements.J","text":"Shorthand for Judgement\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.Judgements.NoJudgement","page":"Home","title":"Taxonomy.Judgements.NoJudgement","text":"Abstaining from any judgement.\n\nThis implies that your best guess is missing and you are absolutely uncertain about this judgement.\n\njulia> NoJudgement()\nJudgement{Missing}(missing, 0.0, missing)\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.Judgements.rating","page":"Home","title":"Taxonomy.Judgements.rating","text":"Extract rating from Judgement.\n\nIf rating is called on a Judgement it returns the rating, on everything it returns identity.  If rating is called on a JudgementLevel together with a field name, it returns the rating of that field. \n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.Judgements.certainty","page":"Home","title":"Taxonomy.Judgements.certainty","text":"Extract certainty from Judgement.\n\nIf certainty is called on a Judgement it returns the certainty, on everything it returns identity.  If certainty is called on a JudgementLevel together with a field name, it returns the certainty of that field. \n\n\n\n\n\n","category":"function"},{"location":"#Metadata","page":"Home","title":"Metadata","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MetaData\napa\njson\nauthor\nyear\njournal\nMinimalMeta\nIncompleteMeta\nExtensiveMeta","category":"page"},{"location":"#Taxonomy.MetaData","page":"Home","title":"Taxonomy.MetaData","text":"Save metadata.\n\nCan be from complete minimal metadata, incomplete metadata or preferably from DOI.\n\njulia> min = MetaData(\"Peikert, Aaron\", 2022, \"Journal of Statistical Software\");\n\njulia> incomplete = MetaData(\"Peikert, Aaron\", 2022, missing);\n\njulia> extensive = MetaData(DOI(\"10.5281/zenodo.6719627\"));\n\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.apa","page":"Home","title":"Taxonomy.apa","text":"Get an APA citation.\n\njulia> apa(DOI(\"10.5281/zenodo.6719627\"))\n\"Ernst, M. S., &amp; Peikert, A. (2022). <i>StructuralEquationModels.jl</i> (Version v0.1.0) [Computer software]. Zenodo. https://doi.org/10.5281/ZENODO.6719627\"\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.json","page":"Home","title":"Taxonomy.json","text":"Get a Citeproc JSON.\n\nCSL JSON Documentation\n\nCSL JSON can be read by Zotero and automatically generated by doi.org from DOI. All availible information are included and saved in a Dict.\n\njulia> json(DOI(\"10.5281/zenodo.6719627\"))\nDict{String, Any} with 11 entries:\n  \"publisher\" => \"Zenodo\"\n  \"issued\"    => Dict{String, Any}(\"date-parts\"=>Any[Any[2022, 6, 24]])\n  \"author\"    => Any[Dict{String, Any}(\"family\"=>\"Ernst\", \"given\"=>\"Maximilian …\n  \"id\"        => \"https://doi.org/10.5281/zenodo.6719627\"\n  \"copyright\" => \"MIT License\"\n  \"version\"   => \"v0.1.0\"\n  \"DOI\"       => \"10.5281/ZENODO.6719627\"\n  \"URL\"       => \"https://zenodo.org/record/6719627\"\n  \"title\"     => \"StructuralEquationModels.jl\"\n  \"abstract\"  => \"StructuralEquationModels v0.1.0 This is a package for Structu…\n  \"type\"      => \"book\"\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.author","page":"Home","title":"Taxonomy.author","text":"Extract the author.\n\njulia> doi = MetaData(DOI(\"10.1126/SCIENCE.169.3946.635\"));\n\njulia> author(doi)\n\"Frank, Henry S.\"\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.year","page":"Home","title":"Taxonomy.year","text":"Extract the year.\n\njulia> doi = MetaData(DOI(\"10.1126/SCIENCE.169.3946.635\"));\n\njulia> year(doi)\n1970\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.journal","page":"Home","title":"Taxonomy.journal","text":"Extract the journal.\n\njulia> doi = MetaData(DOI(\"10.1126/SCIENCE.169.3946.635\"));\n\njulia> journal(doi)\n\"Science\"\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.MinimalMeta","page":"Home","title":"Taxonomy.MinimalMeta","text":"A representation of the most important metadata.\n\njulia> min = MetaData(\"Peikert, Aaron\", 2022, \"Journal of Statistical Software\");\n\njulia> typeof(min)\nMinimalMeta\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.IncompleteMeta","page":"Home","title":"Taxonomy.IncompleteMeta","text":"A representation of Metadata when we can not even capture the most important metadata.\n\njulia> incomplete = MetaData(missing, 2022, \"Journal of Statistical Software\");\n\njulia> typeof(incomplete)\nIncompleteMeta\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.ExtensiveMeta","page":"Home","title":"Taxonomy.ExtensiveMeta","text":"The metadata we can gather from doi.org.\n\njulia> doi = MetaData(DOI(\"10.1126/SCIENCE.169.3946.635\"));\n\njulia> typeof(doi)\nExtensiveMeta{MinimalMeta}\n\n\n\n\n\n","category":"type"},{"location":"#DOI","page":"Home","title":"DOI","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DOI\nUsualDOI\nUnusualDOI\nNoDOI\nNoLocation\nurl\nvalid_doi","category":"page"},{"location":"#Taxonomy.DOI","page":"Home","title":"Taxonomy.DOI","text":"Alias for UsualDOI.\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.UsualDOI","page":"Home","title":"Taxonomy.UsualDOI","text":"Construct a validated DOI\n\nMost valid DOIs (not all) can be simply validated via a regular expression.\n\nArguments\n\ndoi::String: a DOI without resolver (e.g. without doi.org), capitalization does not matter\nfallback::String: an optional fallback link where one maybe can find the content in case the doi fails\n\njulia> DOI(\"10.5281/zenodo.6719627\")\nUsualDOI{String, Missing}(\"10.5281/ZENODO.6719627\", missing)\n\njulia> DOI(\"10.5281/zenodo.6719627\", \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\")\nUsualDOI{String, String}(\"10.5281/ZENODO.6719627\", \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\")\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.UnusualDOI","page":"Home","title":"Taxonomy.UnusualDOI","text":"Construct an unvalidated DOI\n\nYou should prefer an validated UsualDOI but if you have tested the DOI and are sure it links were it supposed to link, go ahead and create an unvalidated doi.\n\njulia> UnusualDOI(\"weird10.5281doi/zenodo.6719627\")\nUnusualDOI{String, Missing}(\"WEIRD10.5281DOI/ZENODO.6719627\", missing)\n\njulia> UnusualDOI(\"weird10.5281doi/zenodo.6719627\", \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\")\nUnusualDOI{String, String}(\"WEIRD10.5281DOI/ZENODO.6719627\", \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\")\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.NoDOI","page":"Home","title":"Taxonomy.NoDOI","text":"What to do if there is no doi\n\nLast resort if there is no DOI. Than we save other metadata, similar to BibTex.\n\nArguments\n\nurl::String: an link where one maybe can find the content in case the doi fails\nauthor::String: like in BibTex, e.g. \"Peikert, Aaron and Ernst, Maximilian S. and Bode, Clifford\"\ndate::Union{Date, Missing}: optional date\nyear::Union{Int64}: optional if date is supplied\njournal::String: The outlet of the publication\nother::Dict: more BibTexlike metadata\n\nNoDOI(\n    url = \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\",\n    author = \"Ernst, Maximilian Stefan and Peikert, Aaron\",\n    title = \"StructuralEquationModels.jl: A fast and flexible SEM framework\",\n    date = Date(\"2022-06-24\"), # year is inferred\n    journal = \"No Real Journal\",\n    awesome = \"Yes\", # other metadata\n    software = \"naturally\", # some more metadata\n    citations = 500\n)\nNoDOI(\n    url = \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\",\n    author = \"Ernst, Maximilian Stefan and Peikert, Aaron\",\n    title = \"StructuralEquationModels.jl: A fast and flexible SEM framework\",\n    year = 2022, # date is omitted\n    journal = \"No Real Journal\"\n)\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.NoLocation","page":"Home","title":"Taxonomy.NoLocation","text":"When everything fails.\n\nThis is a placeholder if really no location can be found.\n\n\n\n\n\n","category":"type"},{"location":"#Taxonomy.url","page":"Home","title":"Taxonomy.url","text":"Get URL from location.\n\njulia> url(DOI(\"10.1126/SCIENCE.169.3946.635\"))\n\"https://doi.org/10.1126/SCIENCE.169.3946.635\"\n\nlocation = NoDOI(\n    url = \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\",\n    author = \"Ernst, Maximilian Stefan and Peikert, Aaron\",\n    title = \"StructuralEquationModels.jl: A fast and flexible SEM framework\",\n    year = 2022, # date is omitted\n    journal = \"No Real Journal\"\n)\n\nurl(location)\n\n# output\n\n\"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\"\n\n\n\n\n\n","category":"function"},{"location":"#Taxonomy.valid_doi","page":"Home","title":"Taxonomy.valid_doi","text":"Validate DOI via Regex\n\nRegular expression taken from:\n\nhttps://www.crossref.org/blog/dois-and-matching-regular-expressions/\n\n\n\n\n\n","category":"function"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"The idea behind doing the coding in Julia is that we can automate two things.","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"We can enforce syntactical requirements with a quick feedback loop for the coder, resulting in less errors.\nWe can automatically infer much information, resulting in speedier and less error prone coding.","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"We implement these automation to detect error/misunderstanding/etc while coding and not long after.","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"To get a feeling for how this is supposed to work, we code the famous political democracy paper together:","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"DocTestFilters = [r\"\\\".*\\\"\", r\"May we suggest: .*\", r\"└ @ Taxonomy .*\"]","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"using Taxonomy \nfirst_record = Record(\n    rater = \"AP\",\n    location = DOI(\"10.2307/2095172\"),\n    Study(Model(StandaloneFactor(\n        n_variables = 6, \n        loadings = [1, 1.19, 0.53, 0.91, 1, 1], \n        factor_variance = J(missing, 0.5), \n        error_covariances_within = [10.7, 12.9, 19])))\n)\n\n# output\n┌ Warning: You really should supply an ID. May we suggest (from DOI): 8f1713c9-482b-58cb-8ed4-128c03e9dafb\n└ @ Taxonomy ~/Dokumente/GitHub/Taxonomy.jl/src/record.jl:20\nRecord\n   rater: String\n   id: Missing\n   location: UsualDOI{String, Missing}\n   meta: ExtensiveMeta{MinimalMeta}\n   judgements: Dict{Symbol, Vector{Union{Study, AbstractJudgement}}}\n","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"DocTestFilters = nothing","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"julia> year(first_record)\n1980\njulia> apa(first_record)\n\"Bollen, K. A. (1980). Issues in the Comparative Measurement of Political Democracy. American Sociological Review, 45(3), 370. https://doi.org/10.2307/2095172\\n\"\njulia> ExtractStudy(first_record)[1].judgements[:Model][1].judgements[:Taxon][1]\nMeasurement\n   n_variables: JudgementInt{Int64}\n   loadings: JudgementVecNumber{Vector{Float64}}\n   factor_variance: JudgementNumber{Missing}\n   error_variances: JudgementVecNumber{Missing}\n   error_covariances_within: JudgementVecNumber{Vector{Float64}}\n   error_covariances_between: JudgementVecNumber{Missing}\n   crossloadings_incoming: JudgementVecNumber{Missing}\n   crossloadings_outgoing: JudgementVecNumber{Missing}\n   quest_scale: JudgementNumber{Missing}","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"Generally, DOIs are the best and easiest thing to get metadata, however, sometimes none is availible:","category":"page"},{"location":"tutorials/start/","page":"Getting Started","title":"Getting Started","text":"using Taxonomy\nRecord(\n    rater = \"AP\", \n    id = \"96ac4220-45d2-43ca-930d-afb67763f56f\", # ID gets recommended by the function.\n    location = NoDOI(\n        url = \"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\",\n        author = \"Ernst, Maximilian Stefan and Peikert, Aaron\",\n        title = \"StructuralEquationModels.jl: A fast and flexible SEM framework\",\n        year = 2022, # date is omitted\n        journal = \"No Real Journal\"\n    ),\n    Study(Model(StandaloneFactor(\n        n_variables = 6, \n        loadings = [1, 1.19, 0.53, 0.91, 1, 1], \n        factor_variance = J(missing, 0.5), \n        error_covariances_within = [10.7, 12.9, 19])))\n)\n\n# output\nRecord\n   rater: String\n   id: Base.UUID\n   location: NoDOI\n   meta: MinimalMeta\n   judgements: Dict{Symbol, Vector{Union{Study, AbstractJudgement}}}","category":"page"}]
}
